#
# Copyright 2016, Noah Kantrowitz
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

require 'base64'
require 'openssl'
require 'securerandom'
require 'shellwords'

require 'kitchen/driver/airlift_base' # THIS IS PART OF THIS PLUGIN FOR NOW
require 'net/ssh'


module Kitchen
  module Driver
    # Driver plugin for Test-Kitchen to use Solaris Zones.
    class Zone < Kitchen::Driver::AirliftBase
      # Mutex for generating SSH keys, important for concurrent kitchen-ing.
      SSH_KEY_MUTEX = Mutex.new

      # Path to the SSH private key to use for authentication, will be created
      # if it does not exist.
      default_config :ssh_key, File.join(Dir.pwd, '.kitchen', 'id_rsa')

      # Name of the zone to create.
      default_config :zone_name do |driver|
        # The zone name identifies the zone to the configuration utility. The following rules apply to zone names:
        #     Each zone must have a unique name.
        #     A zone name is case-sensitive.
        #     A zone name must begin with an alpha-numeric character.
        #     The name can contain alpha-numeric characters, underbars (_), hyphens (-), and periods (.).
        #     The name cannot be longer than 64 characters.
        #     The name global and all names beginning with SUNW are reserved and cannot be used.
        driver.instance.name[0..53] + '-' + SecureRandom.hex(10)
      end

      # NAT port to forward for SSH.
      default_config :zone_port do |driver|
        # TODO this needs to check for collisions.
        rand(65535 - 1025) + 1025
      end

      PROFILE = <<-EOH
create -b
set brand=solaris
set zonepath=/zones/%{name}
set autoboot=false
set autoshutdown=shutdown
set ip-type=exclusive
add anet
set linkname=net0
set lower-link=stub0
set configure-allowed-address=true
set link-protection=mac-nospoof
set mac-address=auto
end
add attr
set name=comment
set type=string
set value="%{comment}"
end
EOH

      CONFIG = <<-EOH
<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
<!-- Auto-generated by sysconfig -->
<service_bundle type="profile" name="sysconfig">
  <service version="1" type="service" name="system/identity">
    <instance enabled="true" name="node">
      <property_group type="application" name="config">
        <propval type="astring" name="nodename" value="%{name}"/>
      </property_group>
    </instance>
  </service>
  <service version="1" type="service" name="network/physical">
    <instance enabled="true" name="default">
      <property_group type="application" name="netcfg">
        <propval type="astring" name="active_ncp" value="Automatic"/>
      </property_group>
    </instance>
  </service>
  <service version="1" type="service" name="system/name-service/switch">
    <property_group type="application" name="config">
      <propval type="astring" name="default" value="files"/>
    </property_group>
    <instance enabled="true" name="default"/>
  </service>
  <service version="1" type="service" name="system/name-service/cache">
    <instance enabled="true" name="default"/>
  </service>
  <service version="1" type="service" name="system/environment">
    <instance enabled="true" name="init">
      <property_group type="application" name="environment">
        <propval type="astring" name="LANG" value="en_US.UTF-8"/>
      </property_group>
    </instance>
  </service>
  <service version="1" type="service" name="system/timezone">
    <instance enabled="true" name="default">
      <property_group type="application" name="timezone">
        <propval type="astring" name="localtime" value="UTC"/>
      </property_group>
    </instance>
  </service>
  <service version="1" type="service" name="system/config-user">
    <instance enabled="true" name="default">
      <property_group type="application" name="root_account">
        <propval type="astring" name="type" value="role"/>
        <propval type="astring" name="login" value="root"/>
        <propval type="astring" name="password" value=""/>
      </property_group>
      <property_group type="application" name="user_account">
        <propval type="astring" name="shell" value="/usr/bin/bash"/>
        <propval type="astring" name="login" value="kitchen"/>
        <propval type="astring" name="password" value="NP"/>
        <propval type="astring" name="type" value="normal"/>
        <propval type="astring" name="sudoers" value="ALL=(ALL) NOPASSWD: ALL"/>
        <propval type="count" name="gid" value="10"/>
        <propval type="astring" name="description" value="kitchen"/>
        <propval type="astring" name="profiles" value="System Administrator"/>
        <property type="astring" name="ssh_public_keys">
          <astring_list>
              <value_node value="%{public_key}"/>
          </astring_list>
       </property>
      </property_group>
    </instance>
  </service>
</service_bundle>
EOH

      def create(state)
        zone_name = state[:zone_name] = config[:zone_name]

        # Generate SSH key if needed.
        SSH_KEY_MUTEX.synchronize do
          unless File.exist?(config[:ssh_key])
            File.open(config[:ssh_key], 'w') do |file|
              file.chmod(0600)
              # 2048 is good enough for this ephemeral usage, and faster than 4096.
              file.write(OpenSSL::PKey::RSA.new(2048))
            end
          end
        end

        # Extract the SSH public key to pass to sysconfig.
        private_key = OpenSSL::PKey::RSA.new(IO.read(config[:ssh_key]))
        blobbed_key = Base64.encode64(private_key.to_blob).gsub(/\n/, '')
        public_key = "ssh-rsa #{blobbed_key} kitchen_zone"

        # Create a temp dir to hold some config files.
        # TODO implement the #tempfile method in Airlfit and convert this.
        tempdir = airlift.execute!('mktemp -d').stdout.strip

        begin
          # Create the zone config.
          comment = "Created by #{Etc.getlogin || 'unknown'} on #{Socket.gethostname} at #{Time.now}"
          airlift.file("#{tempdir}/profile.cfg").content = PROFILE % {name: zone_name, comment: comment}
          airlift.file("#{tempdir}/profile.xml").content = CONFIG % {name: zone_name, public_key: public_key}

          # Clone the template zone.
          airlift.execute!("/usr/sbin/zonecfg -z #{zone_name} -f #{tempdir}/profile.cfg")
          airlift.execute!("/usr/sbin/zoneadm -z #{zone_name} clone -c #{tempdir}/profile.xml template")

          # Boot the zone.
          airlift.execute!("/usr/sbin/zoneadm -z #{zone_name} boot")
        ensure
          # Clean up the config.
          airlift.execute!("rm -rf #{tempdir}") unless config[:keep_config]
        end

        # Wait for networking.
        info "Waiting for zone #{zone_name} to start"
        while true # TODO this should have a timeout
          sleep(5)
          cmd = airlift.execute('/usr/sbin/zlogin', zone_name, 'ipadm show-addr')
          if !cmd.error? && cmd.stdout =~ %r{net0/v4\s+dhcp\s+ok\s+([0-9.]+)/24}
            state[:zone_ip] = $1
            break
          end
        end

        # Set up NAT.
        state[:zone_port] = config[:zone_port]
        airlift.execute!('sh', '-c', "echo \"rdr net0 0.0.0.0/0 port #{state[:zone_port]} -> #{state[:zone_ip]} port 22\" | /usr/sbin/ipnat -f -")

        # Populate the state for the transport.
        state[:hostname] = config[:transport][:host]
        state[:port] = state[:zone_port]
        state[:username] = 'kitchen'
      end

      def destroy(state)
        if state[:zone_port] && state[:zone_ip]
          airlift.execute('sh', '-c', "echo \"rdr net0 0.0.0.0/0 port #{state[:zone_port]} -> #{state[:zone_ip]} port 22\" | /usr/sbin/ipnat -r -f -")
          state.delete(:zone_port)
          state.delete(:zone_ip)
        end
        if state[:zone_name]
          [
            "/usr/sbin/zoneadm -z #{state[:zone_name]} halt",
            "/usr/sbin/zoneadm -z #{state[:zone_name]} uninstall -F",
            "/usr/sbin/zonecfg -z #{state[:zone_name]} delete -F",
          ].each do |cmd|
            airlift.execute(cmd)
          end
          state.delete(:zone_name)
        end
      end

    end
  end
end
